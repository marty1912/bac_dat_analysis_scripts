---
title: "Analyse Gruppe 1"
params:
  hyp: rig
output:
  html_document: default
  pdf_document: default
---

## start by looking at the data:
 ```{r }
 library(PairedData)
 library(ggplot2)
library(ggpubr)
library(apaTables)
library(papaja)
library(knitr)
library(tidyverse)
library(rstatix)
library(ez)
library(BayesianFirstAid)
 
 ```

 ```{r}
dat <- read.csv("data_with_dist_effect_1rpP.csv")
dat_all <-  read.csv("data_cleaned_complete.csv")
dat_accuracy <-  read.csv("data_accuracy_part_mode.csv")
dat_accuracy_dual <-  read.csv("data_accuracy_p_participant_dual.csv")

```

 ```{r }
ggdensity(dat_all, x = "rt_num",
   add = "mean", rug = TRUE,
   color = "mode", fill = "mode",
   palette = "jco")
 
 ```
 
 ```{r }
ggdensity(dat_accuracy, x = "accuracy",
   add = "mean", rug = TRUE,
   color = "mode", fill = "mode",
   palette = "jco")
 
 ```
  ```{r }
ggdensity(dat_accuracy_dual, x = "accuracy",
   add = "mean", rug = TRUE,
   color = "mode", fill = "mode",
   palette = "jco")
 
 ```
 
  ```{r }
ggboxplot(dat_all, x = "mode", y = "rt_num",
                color = "mode", palette ="jco"
                , shape = "mode")
 
 ```

 ```{r}
#TODO: check for pratice effect.
#dat_all$datetime <- as.Date(dat_all$datetime)

 # check means and sds so we get an overview.
as.data.frame(t(sapply(dat, function(cl) list(means=mean(cl,na.rm=TRUE), sds=sd(cl,na.rm=TRUE)))))



 ```

 ```{r}

 # define  a function so we dont have to write this everytime
t_test_and_plot <- function(data,x_labels_to_use=c("1","2"),x_lab="Distanz",y_lab="Reaktionszeit in s",cols=c("mean_rt.1.FALSE.single","mean_rt.2.FALSE.single")){

dat <- data %>% select(prob_code,as.symbol(cols[1]),as.symbol(cols[2]))

# assumption test:
# step 1 calc the difference between the values (paired samples t test does the same)
dat <- dat %>% mutate(diff = get(cols[1])-get(cols[2]))

# from doc of identify outliers:
# Values aboveQ3 + 1.5xIQR or below Q1 -1.5xIQR are considered as outliers.  
# Values aboveQ3 +3xIQRor belowQ1 -3xIQRare considered as extreme points (or extreme outliers).
# Q1 and Q3 are the first and third quartile, respectively.  
# IQR is the interquartile range (IQR = Q3 -Q1).
outliers <- dat %>% identify_outliers(diff)

# remove the outliers:
#dat <- dat %>% filter(!(prob_code %in% outliers$prob_code))

# perform shapiro test:
shapiro <- dat %>% shapiro_test(diff)

# plot for visual inspection
qqplot <- ggqqplot(dat, "diff")



paired_plot <- ggpaired(dat, cond1 = cols[1], cond2 = cols[2], 
    fill = "condition"
    , palette = "jco"
    ,line.size=0.1
    ,point.size=0.0
    ,width=0.5
    ,short.panel.labs=TRUE
    ,xlab= x_lab
    ,ylab= y_lab
    ) + scale_x_discrete(labels=x_labels_to_use)
    

vec_val <- dat[,cols[1]]
vec_cond <- rep(cols[1],length(vec_val))

vec_val <-append(vec_val,dat[,cols[2]])
vec_cond <- append(vec_cond,rep(cols[2],length(vec_val)-length(vec_cond)))

dat_plot <- data.frame(vec_val,vec_cond)
dat_plot <- dat_plot[complete.cases(dat_plot),]

bar_plot <- ggbarplot(
          data=dat_plot,
          x="vec_cond",
          y="vec_val",
          add="mean_se",
        fill = "vec_cond",
        palette = "jco",
        ,xlab= x_lab
        ,ylab= y_lab
  #      ,label=TRUE
 #       ,lab.nb.digits=3

          )+ 
 stat_compare_means(method= "t.test", paired=TRUE ,label="p.signif", label.x = 1.5)+ # Add significance levels
scale_x_discrete(labels=x_labels_to_use)+
    theme_apa()

ggp <- ggplot_build(bar_plot)
#my.ggp.yrange <- ggp$layout$panel_scales_y[[1]]$range$range  # data range!
#my.ggp.xrange <- ggp$layout$panel_scales_x[[1]]$range$range  # data range!
y_range <- ggp$layout$panel_params[[1]]$y.range[2]
#ggp$layout$panel_params[[1]]$y.range
bar_plot <- bar_plot + geom_bracket( xmin=1,xmax=2,y.position=y_range*0.9,label="")  
          
# perform t test
t_test_res <- t.test(dat[,cols[1]],dat[,cols[2]],paired=TRUE,alternative="two.sided")



# if the shapiro test is significant we should use the non parametric wilcoxon test instead of the t test
wilcox_res <- wilcox.test(dat[,cols[1]],dat[,cols[2]],paired=TRUE,alternative="two.sided")

# print results in latex format
print_apa_t <- apa_print.htest(t_test_res)

print_apa_wilcox <- apa_print.htest(wilcox_res)


return(list( 
# qqplot=qqplot,
# paired_plot=paired_plot,
 bar_plot=bar_plot,
# outliers=outliers,
 shapiro=shapiro,
 t_test_res=t_test_res,
 wilcox_res=wilcox_res #,
# print_apa_t=print_apa_t,
# print_apa_wilcox=print_apa_wilcox
            ))
}

 ```

# distance effect:

Bei ungeordneten Zahlenfolgen werden kleinere AbstÃ¤nde langsamer identifiziert.


## single task


 ```{r }


res <- t_test_and_plot(dat,
x_labels_to_use = c("1","2"),
    x_lab= "Distanz",
    y_lab= "Reaktionszeit in s", 
cols=c("mean_rt.1.FALSE.single",  "mean_rt.2.FALSE.single"))
res

```

## dual phonological 

 ```{r}

t_test_and_plot(dat,
x_labels_to_use = c("1","2"),
    x_lab= "Distanz",
    y_lab= "Reaktionszeit in s", 
cols=c("mean_rt.1.FALSE.dual_phon",  "mean_rt.2.FALSE.dual_phon"))

```

## dual visual 

 ```{r}

t_test_and_plot(dat,
x_labels_to_use = c("1","2"),
    x_lab= "Distanz", y_lab= "Reaktionszeit in s",
cols=c("mean_rt.1.FALSE.dual_vis",  "mean_rt.2.FALSE.dual_vis"))

```

## dual executive

 ```{r}

t_test_and_plot(dat,
x_labels_to_use = c("1","2"),
    x_lab= "Distanz", y_lab= "Reaktionszeit in s",
cols=c("mean_rt.1.FALSE.dual_rig",  "mean_rt.2.FALSE.dual_rig"))

```



# reverse distance effect:

## single

 ```{r}

t_test_and_plot(dat,
x_labels_to_use = c("1","2"),
    x_lab= "Distanz", y_lab= "Reaktionszeit in s",
cols=c("mean_rt.1.TRUE.single",  "mean_rt.2.TRUE.single"))

```

## dual phonological 

 ```{r}
t_test_and_plot(dat,
x_labels_to_use = c("1","2"),
    x_lab= "Distanz", y_lab= "Reaktionszeit in s",
cols=c("mean_rt.1.TRUE.dual_phon",  "mean_rt.2.TRUE.dual_phon"))

```

## dual visual 

 ```{r}

t_test_and_plot(dat,
x_labels_to_use = c("1","2"),
    x_lab= "Distanz", y_lab= "Reaktionszeit in s",
cols=c("mean_rt.1.TRUE.dual_vis",  "mean_rt.2.TRUE.dual_vis"))

```

## dual executive

 ```{r}
t_test_and_plot(dat,
x_labels_to_use = c("1","2"),
    x_lab= "Distanz", y_lab= "Reaktionszeit in s",
cols=c("mean_rt.1.TRUE.dual_rig",  "mean_rt.2.TRUE.dual_rig"))
```



# comparison of distance effects:


## single vs. phon 

 ```{r}
t_test_and_plot(dat,
x_labels_to_use = c("single","dual phon"),
    x_lab= "Bedingung", y_lab= "distance effect",
cols=c("dist_effect_normed.FALSE.single",  "dist_effect_normed.FALSE.dual_phon"))
```

## single vs. vis

 ```{r}
t_test_and_plot(dat,
x_labels_to_use = c("single","dual vis"),
    x_lab= "Bedingung", y_lab= "distance effect",
cols=c("dist_effect_normed.FALSE.single",  "dist_effect_normed.FALSE.dual_vis"))
```

## single vs. dual executive

 ```{r}

t_test_and_plot(dat,
x_labels_to_use = c("single","dual rig"),
    x_lab= "Bedingung", y_lab= "distance effect",
cols=c("dist_effect_normed.FALSE.single",  "dist_effect_normed.FALSE.dual_rig"))

```

# comparison of reverse distance effects:

## single vs. phon 

 ```{r}
t_test_and_plot(dat,
x_labels_to_use = c("single","dual phon"),
    x_lab= "Bedingung", y_lab= "reverse distance effect",
cols=c("rev_dist_effect_normed.TRUE.single",  "rev_dist_effect_normed.TRUE.dual_phon"))
```

## single vs. vis 

 ```{r}
t_test_and_plot(dat,
x_labels_to_use = c("single","dual vis"),
    x_lab= "Bedingung", y_lab= "reverse distance effect",
cols=c("rev_dist_effect_normed.TRUE.single",  "rev_dist_effect_normed.TRUE.dual_vis"))
```

## single vs. dual executive

 ```{r}
t_test_and_plot(dat,
x_labels_to_use = c("single","dual rig"),
    x_lab= "Bedingung", y_lab= "reverse distance effect",
cols=c("rev_dist_effect_normed.TRUE.single",  "rev_dist_effect_normed.TRUE.dual_rig"))

```


 ```{r echo=FALSE}

#### Rscript -e 'library(rmarkdown); rmarkdown::render("analysis.Rmd", "pdf_document",params = list(filename = "analysis.pdf"))'

```

 ```{r echo=FALSE}

dat <- read.csv("data_cleaned.csv")

# TODO: remove participants completely.

dat <- dat %>% filter(!is.na(rt_num))
data_excluded <- read.csv("excluded_participants_p_mode.csv")
print(nrow(dat))
dat$distance <- as.factor(dat$distance)


#dat_incomplete <- dat %>% group_by(prob_code,distance,ordered,mode) %>% summarize(n = n(),na.rm=FALSE) %>% filter((!is.na(n)) &(n != 0)) 

#(dat_incomplete)
#dat <- dat %>% filter((prob_code %in% dat_incomplete$prob_code ))
  


#if(FALSE){
dat_true <- dat %>% filter((ordered == TRUE))
dat_false <- dat %>% filter((ordered == FALSE))

dat_true_1 <- dat_true %>% filter((distance == 1))
dat_false_1 <- dat_false %>% filter((distance == 1))
dat_true_2 <- dat_true %>% filter((distance == 2))
dat_false_2 <- dat_false %>% filter((distance == 2))


dat_true_1_single <- dat_true_1 %>% filter((mode == "single"))
dat_false_1_single <- dat_false_1 %>% filter((mode == "single"))
dat_true_2_single <- dat_true_2 %>% filter((mode == "single"))
dat_false_2_single <- dat_false_2 %>% filter((mode == "single"))

dat_true_1_dual_rig <- dat_true_1 %>% filter((mode == "dual_rig"))
dat_false_1_dual_rig <- dat_false_1 %>% filter((mode == "dual_rig"))
dat_true_2_dual_rig <- dat_true_2 %>% filter((mode == "dual_rig"))
dat_false_2_dual_rig <- dat_false_2 %>% filter((mode == "dual_rig"))

dat_true_1_dual_phon <- dat_true_1 %>% filter((mode == "dual_phon"))
dat_false_1_dual_phon <- dat_false_1 %>% filter((mode == "dual_phon"))
dat_true_2_dual_phon <- dat_true_2 %>% filter((mode == "dual_phon"))
dat_false_2_dual_phon <- dat_false_2 %>% filter((mode == "dual_phon"))

dat_true_1_dual_vis <- dat_true_1 %>% filter((mode == "dual_vis"))
dat_false_1_dual_vis <- dat_false_1 %>% filter((mode == "dual_vis"))
dat_true_2_dual_vis <- dat_true_2 %>% filter((mode == "dual_vis"))
dat_false_2_dual_vis <- dat_false_2 %>% filter((mode == "dual_vis"))

dat <- dat %>% filter((prob_code %in% dat_true_1_single$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_false_1_single$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_true_2_single$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_false_2_single$prob_code ))

dat <- dat %>% filter((prob_code %in% dat_true_1_dual_rig$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_false_1_dual_rig$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_true_2_dual_rig$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_false_2_dual_rig$prob_code ))

dat <- dat %>% filter((prob_code %in% dat_true_1_dual_phon$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_false_1_dual_phon$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_true_2_dual_phon$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_false_2_dual_phon$prob_code ))

dat <- dat %>% filter((prob_code %in% dat_true_1_dual_vis$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_false_1_dual_vis$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_true_2_dual_vis$prob_code ))
dat <- dat %>% filter((prob_code %in% dat_false_2_dual_vis$prob_code ))
#}




ez_aov <- ezANOVA(data=dat,dv=rt_num,wid=prob_code,within=.(distance,ordered,mode))
apa.ezANOVA.table(ez_aov)
```

